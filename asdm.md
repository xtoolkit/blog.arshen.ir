# استاندارد آرشن: مدیریت داده ها

## مقدمه

با پیشرفت علم و توسعه سیستم ها، یکی از چالش های پیش روی انسان برده شدن توسط سیستم ها و تن دادن به خواسته های آن های می باشد! به طوری که سیستم به ما دستور می دهد چه کار کنیم، چه را انتخاب کنیم و... . در صورتی که سیستم با هدف فرمانبرداری از انسان ایجاد شده اند. از این رو باید سیستم ها را به سمت پیشنهاد و نه تحمیل خواسته ها توسعه دهیم.

چالش بعدی انسان مدیریت داده ها (مکان، امنیت ، نوع و ...) می باشد که در سیستم های جدید قابل مشاهده می باشد. به طور مثال، اپلیکیشن، اطلاعات ما را کجا، به چه شکل و به چه نوع و با چه امنیتی ذخیره میکند و چگونه مستقیم به آن اطلاعات ارتباط برقرار کنیم. مثال دیگر میتوان به نصب یه اسکریپت خاص اشاره کرد که شما را وادار به استفاده از پایگاه داده x می کند و برای کاربر حق انتخابی نمیگذارد!

از این رو نیاز به یک سیستم مدیریت داده های جامع احساس می شود که یک رابط بین انواع مدیریت داده ها با اپلیکیشن ها می باشد که توانایی پاسخ و یا بهبود خواسته های ما را داشته باشد! در این مطلب در مورد ساختار کلی این سیستم مدیریت داده های جامع در اسکریپت های تحت وب با زبان php مورد بررسی قرار می گیرد.

## چالش اصلی: نیاز به تعیین یک ساختار استاندارد

اولین چالش رو به روی این سیستم تفاوت بنیادی بین پایگاه/ناپایگاه داده های SQL و NoSQL می باشد. برای ساده سازی بحث تفاوت های json (ساده ترین NoSQL و فارق از محدودیت ها) و MySQL را بررسی میکنیم. در MySQL یک بعد درخواست یک جدول به صورت مجازی نمایش داده می شود.  یک مثال ساده از لیست پلاگین های اسکریپت در جدول پلاگین ها:

```
+----+----------+--------+
| id | name     | active |
+----+----------+--------+
|  1 | news     |      1 |
|  2 | page     |      1 |
|  6 | calendar |      0 |
|  7 | msample  |      0 |
|  8 | users    |      1 |
+----+----------+--------+
```
اما json یک فایل می باشد که برای استفاده از آن باید آن را رندر کرد. مثال از فایل:

``` json
{
  "plugins": {
    "news": true,
    "page": true,
    "calendar": false,
    "msample": false,
    "users": true
  }
}
```

در پس زمینه MySQL صفات دارای ویژگی های نوع داده، اندازه داده، رابطه، نوع کد گذاری، ویژگی null بودن، indexing و تکمیل خودکار می باشد. در json هیچ کدام از این ویژگی ها وجود ندارد ولی این ویژگی ها را می توان در فایل json گنجاند و در سمت اپلیکیشن آن ها را کنترل کرد. به طور مثال یک فایل از دیتابیس و یک فایل برای تنظیمات خواهیم داشت:

فایل از دیتابیس:

``` json
{
  "plugins": [{
      "id": 1,
      "name": "news",
      "active": true
    },
    {
      "id": 2,
      "name": "page",
      "active": true
    },
    {
      "id": 3,
      "name": "calendar",
      "active": false
    },
    {
      "id": 4,
      "name": "msample",
      "active": false
    },
    {
      "id": 5,
      "name": "users",
      "active": true
    }
  ]
}
```

فایل تنظیمات:

``` json
{
  "configs": {
    "plugins": {
      "cols": {
        "id": {
          "type": "int",
          "length": 12,
          "index": [
            "primary",
            "unique"
          ],
          "auto_increment": true
        },
        "name": {
          "type": "varchar",
          "length": 40
        },
        "active": {
          "type": "bool"
        }
      },
      "default": {
        "character_base": "utf8",
        "character": "utf8_general_ci"
      },
      "last_auto_increment": {
        "id": 5
      }
    }
  }
}
```

اما آیا می توان از بعضی از این ویژگی ها صرف نظر کرد؟ منظور از صرف نظر آن است که کدام ویژگی ها قابلیت کنترل در سمت اپلیکیشن را دارند و می تواند از بار تفاوت های پایگاه/ناپایگاه های داده کاهش داد!

### نوع و اندازه داده

در MySQL حتما باید نوع و اندازه صفت ابتدا تعیین شود و که این کار باعت بهینگی درخواست ها خواهد شد. اما در json صفت ها بدون نوع و محدوده قرار میگیرند. بدیهی است که به دلیل اجباری بودن تعیین نوع و اندازه در بعضی از نوع ها (مانند int) در زمان تعریف صفت در MySQL، نمیتوان از آنها صرف نظر کرد. با این وجود در json نوع و اندازه چگونه خواهد بود؟ دو حالت وجود دارد: یا برنامه نویس باید در اپلیکیشن صحت نوع و اندازه را بررسی نماید و یا در سیستم مدیریت جامع داده ها مورد بررسی قرار گیرد.

#### حالت اول: بررسی در اپلیکیشن

در این حالت برنامه نویس باید بعد از دریافت پاسخ درخواست خود، صحت نوع و اندازه آن ها را بررسی نماید و به ازای هر سطر یه بررسی صورت گیرد. بدیهی است هزینه این عملیات o(n) خواهد بود که در هر بار درخواست آن جدول تکرار خواهد شد و هزینه آن o(n^2) خواهد شد.

#### حالت دوم: بررسی در سیستم جامع مدیریت داده ها

در این حالت وقتی اپلیکیشن یا برنامه نویس سطری را به جدول ارسال می کند قبل از ثبت در جدول صحت نوع و اندازه آن را بررسی نماییم. با این روش در حالت آرمانی زمانی که اپلیکیشن یا برنامه نویس درخواستی انجام دهند نیازی به بررسی نخواهد بود و هزینه آن o(1) خواهد بود. اما اگر کاربر به صورت دستی پایگاه داده را مورد ویرایش قرار داده باشد خطا رخ میدهد. پس نیاز به بررسی در زمان درخواست خواهد بود و هزینه در حالت کلی مانند حالت اول خواهد شد.

برای رفع این مشکل میتوان زمان آخرین ویرایش جدول توسط سیستم و کاربر را در جدول configs جدول ها قرار داد و اگر کاربر جدول را به طور دستی تغییر داد زمان هم تغییر دهد تا این حالت تشخیص داده شده و یک بار کل جدول بازبینی شود.

#### نتیجه

با بررسی دو حالت بالا می توان نتیجه گرفت که در صورت تضمین تغییر زمان توسط کاربر، زمان تغییر جدول به صورت دستی، حالت دوم بهتر خواهد بود. همچنین میتوان حالت اضافه تری هم در نظر گرفت و که در جدول قید شود که این جدول در حین درخواست بررسی شود یا خیر.

### قابلیت رابطه

در دیتا مدل وابستگی بین داده ها مطرح می شود که این صفت ها ممکن است به به صفت یه جدول دیگر وابسته باشد. در این قسمت بحث دیگری که مطرح می شود مسئله join می باشد. در بحث لزوم وجود join بحثی نیست و هر دو ویژگی قابلیت اجرا در json را دارند. اما آیا رابطه ها لزومی می باشند؟ در یک رابطه یک به چند در sql در صورت اشتباه خطا داده میشود و این به آن معنی می باشد که به هر حال هزینه o(n) برای یک رابطه وجود خواهد داشت. پس می توان آن را به بخش اپلیکیشن منتقل کرد و خود برنامه نویس آن را به صورت بهینه کنترل کند.

### نوع کد گذاری

در MySQL کد گزاری در 41 دسته و 444 نوع وجود دارد. مانند گروه utf8 که دارای کد گذاری utf8_persian_ci و utf8_general_ci و ... . به دلیل آنکه برنامه ساز مجبور است برای هر زبان نوع خاصی از کد گزاری را اننحاب کند، بدیهی است که نمی توان از این بخش صرف نظر کرد. اما در json چگونه خواهد بود؟ یک حالت آن است بدون در نظر گرفتن کد گذاری داده ها را قرار دهیم. در benchmark های صورت گرفته در انواع کد گذاری ها در MySQL نشان داد که تفاوت های زمانی در داده وجود دارد. اما آیا این benchmark در فایل json هم متفاوت است؟

در نتایج بررسی ها صورت گرفته برای NoSQL mongodb نشان داده شد که با در نظر گرفتن تمام حالات در bson تفاوت زمانی قابل توجه ای دیده نمی شود. پس در این گونه NoSQL ها نیازی به کد گزاری نمی باشد و تمامی داده ها به صورت استاندارد utf8 ذخیره می شود. با در نظر گرفتن تمامی بررسی ها می توان نتیجه گرفت که برنامه نویس حالت کد گذاری را در نظر بگیرد.

## چالش دوم: حجم داده
